#数据容器(Container)分为下面两种
可变容器(Mutable)有列表(List)、集合(Set)、字典(Dictionary)。
不可变容器(lmmutable)有 字符串、range()生产的等差数列、元组(Tuple)。
集合又分为Set和Frozen Set.Set可变 Frozen Set是不可变的。
 
#字符串、由 range() 函数生成的等差数列、列表、元组是有序类型（Sequence Type），而集合与字典是无序的，另外，集合没有重合元素。

#迭代（Iterate）
数据容器里的元素是可以被迭代的（Iterable），它们其中包含的元素，可以被逐个访问，以便被处理。
对于数据容器，有一个操作符，in，用来判断某个元素是否属于某个容器。

#列表（List）
列表是个有序类型（Sequence Type）的容器，其中包含着有索引编号的元素。

#**List Comprehension**.
List comprehension 可以嵌套使用 for，甚至可以加上条件 if。

#列表的操作符
列表的操作符和字符串一样，因为它们都是有序容器。列表的操作符有：
拼接：+（与字符串不一样的地方是，不能用空格 ' ' 了）
复制：*
逻辑运算：in 和 not in，<、<=、>、>=、!=、==
而后两个列表也和两个字符串一样，可以被比较，即，可以进行逻辑运算；比较方式也跟字符串一样，从两个列表各自的第一个元素开始逐个比较，“一旦决出胜负马上停止”：
列表当然也可以根据索引操作，但由于列表是可变序列，所以，不仅可以提取，还可以删除，甚至替换。

#根据索引删除
del 是个命令，del c_list[3] 是一个语句；不能这么写：print(del c_list[3])

#根据索引替换
c_list[1:5:2] = ['a', 2]  # s[start:stop:step] = t，跟 range 的三个参数类似；
                         # len(t) = len([start:stop:step]) 必须为真
print(c_list)

#需要注意的地方是：列表（List）是可变序列，而字符串（str）是不可变序列，所以，对字符串来说，虽然也可以根据索引提取，但没办法根据索引删除或者替换。
字符串常量是不可变有序容器，所以，虽然字符串也有一些方法可用，但哪些方法都不改变它们自身，而是在操作后返回一个值给另外一个变量。
但列表这种可变容器，进行操作后，结果是它本身被改变了。

#列表可用的内建函数
len()   长度
max()   最多的
min()   中间的

#列表是可变类型，使用 sort() 进行排序。
注意：被比较的元素应该是同一类型，不是由同一种数据类型元素构成的列表，不能使用 sort() 。
可变序列还有一系列可用的 Methods：
#在末尾追加一个元素 a.append() 
#清空序列 a.clear()
#拷贝一个列表a.copy()   # 对一个拷贝操作，不会更改 “原件”
#在末尾追加一个列表a.extend(t)             
#在某索引位置插入一个元素a.insert(i，x)
#有一个命令、两个 Methods 与删除单个元素相关联，del，a.pop([i])，a.remove(x)，请注意它们之间的区别。
#删除a.pop([i]) #pop() 删除并返回被删除的值   #pop() 与 del，或者 remove() 的区别
#删除a.remove(x)
#排序a.reverse()


#元组（Tuple）
List 是可变有序容器，Tuple 是不可变有序容器。
List 用方括号标识 []，Tuple 用圆括号 标识 ()。多个元素之间用逗号分离。创建单个元素的元组，无论是否使用圆括号，在那唯一的元素后面一定要补上一个逗号。
元组是不可变序列，无法删除元素。
可以在末尾追加元素。
“不可变” 的意思是说，“当前已有部分不可变”


#集合（Set）
不包含重合元素，是无序的；集合分为两种，Set，可变的，Frozen Set，不可变的。
创建一个集合，用花括号 {} 把元素括起来，用 , 把元素隔开：
注意：创建空集合的时候，必须用 set()，而不能用 {}:

#也可以将序列数据转换（Casting）为集合。转换后，返回的是一个已去重的集合。

#将序列类型数据转换成 Set，就等于去重。当然，也可以用 in 来判断某个元素是否属于这个集合。
len()、max()、min()，都可以用来操作 Set，del 不行 —— 因为 Set 中的元素没有索引（它不是有序容器）。
从 Set 里删除元素，得用 set.remove(elem)；
而 Frozen Set 是不可变的，所以不能用 set.remove(elem) 操作。


#对于集合，有相应的操作符可以对它们进行集合运算：
并集：|
交集：&
差集：-
对称差集：^
意义     操作符      Methods                        Methods 相当于
并集       |      set.union(*others)                  set | other | ...
交集       &      set.intersection(*others)           set & other & ...
差集       -      set.difference(*others)             set - other - ...
对称差集   ^      set.symmetric_difference(other)     set ^ other
注意，并集、交集、差集的 Methods，可以接收多个集合作为参数 (*other)，但对称差集 Method 只接收一个参数 (other)。


#字典（Dictionary）
Map 是容器中的单独一类，映射（Map）容器。映射容器只有一种，叫做字典（Dictionary）。
字典里的每个元素，由两部分组成，_key_（键）和 _value_（值），二者由一个冒号连接。
比如，'ann':6575 这个字典元素，key 是 'ann'，value 是 6575。
字典直接使用 key 作为索引，并映射到与它匹配的 _value_：
在同一个字典里，key 都是唯一的。如果其中有重复的 key ，会 “自动去重” —— 保留的是 key 中的最后一个 _key:value_（或者说，最后一个 key:value “之前那个 key 的 value 被更新了”）。
字典这个数据类型之所以叫做 Map（映射），是因为字典里的 key 都映射且只映射一个对应的 _value_。

更新元素 dict['key']=value
添加元素dict.update（key）
删除某元素 del dict [key]

可用内建函数
len()
max()
min()
list()
tuple()
set()
sorted()
sorted(phonebook1, reverse=True)


#想同时得到有序容器中的元素及其索引，那么可以调用 enumerate() 函数来帮我们：
可以用 sorted() 和 reversed() 在迭代前先排好序：
可以在 zip() 这个函数的帮助下，同时迭代两个或者两个以上的容器中的元素（这样做的前提是，多个容器中的元素数量最好相同）：